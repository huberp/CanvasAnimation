# Research: 2D Bounding Shape Algorithms for Collision Detection

## Overview
This document contains research on algorithms for computing 2D bounding shapes for sprite-based collision detection. The goal is to find efficient methods to generate bounding polygons around irregular sprite shapes like asteroid4.

## Algorithm Options

### 1. Marching Squares Algorithm + Douglas-Peucker Simplification (Recommended)

**Description:**
- **Marching Squares**: Extracts contours from 2D images by analyzing pixel data and creating paths along edges
- **Douglas-Peucker**: Simplifies the resulting polygon by reducing the number of points while preserving shape

**Pros:**
- Most accurate representation of irregular shapes
- Works directly with image pixel data
- Can handle transparent areas automatically
- JavaScript implementations available
- Can control polygon complexity via tolerance parameter

**Cons:**
- More computationally intensive than simple bounding boxes
- Requires image processing

**Relevance:** ⭐⭐⭐⭐⭐ (Highest - Best for irregular asteroid shapes)

**Links:**
- [MSQR - Fast Marching Squares JavaScript Library](https://github.com/OSUblake/msqr) ✓ (GitHub)
- [Marching Squares Interactive Tutorial](https://jurasic.dev/marching_squares/) ✓ (Web)
- [Ramer-Douglas-Peucker JavaScript Implementation](https://github.com/CMihalcik/rdp-js) ✓ (GitHub)
- [Observable: RDP on Typed Arrays](https://observablehq.com/@chnn/running-ramer-douglas-peucker-on-typed-arrays) ✓ (Web)

### 2. Convex Hull Algorithms

**Description:**
- Computes the smallest convex polygon that contains all visible pixels
- Common algorithms: Graham's Scan, Andrew's Monotone Chain, Gift Wrapping

**Pros:**
- Simpler collision detection with Separating Axis Theorem (SAT)
- Fast computation
- Good for convex or nearly-convex shapes

**Cons:**
- May not fit irregular concave shapes well (like asteroids)
- Can have significant empty space for highly irregular shapes

**Relevance:** ⭐⭐⭐ (Medium - Better for simpler shapes)

**Links:**
- [Collision Detection for Irregular Shapes - Stack Overflow](https://gamedev.stackexchange.com/questions/86109/collision-detection-between-2-irregular-shapes) ✓ (Web)
- [MDN: 2D Collision Detection](https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection) ✓ (Web)

### 3. Axis-Aligned Bounding Box (AABB)

**Description:**
- Simple rectangular bounding box aligned with coordinate axes
- Computed from min/max x and y coordinates

**Pros:**
- Extremely fast computation
- Minimal memory usage
- Very fast collision detection
- Good for broad-phase collision detection

**Cons:**
- Poor fit for irregular or rotated shapes
- Many false positives for collision detection
- Not suitable as the only collision method for irregular shapes

**Relevance:** ⭐⭐ (Low - Too simple for irregular asteroids, but useful for broad-phase)

**Links:**
- [MDN: 2D Collision Detection - AABB](https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection) ✓ (Web)

### 4. Separating Axis Theorem (SAT) for Polygon Collision

**Description:**
- Collision detection algorithm for convex polygons
- Projects shapes onto axes and checks for overlap
- Works with polygons generated by other methods

**Pros:**
- Very efficient for convex polygon collision detection
- Accurate collision detection
- Widely used in game engines

**Cons:**
- Requires convex polygons (or decomposition of concave ones)
- More complex to implement than simple methods

**Relevance:** ⭐⭐⭐⭐ (High - Good collision detection method to use with generated bounding polygons)

**Links:**
- [Stack Overflow: 2D Polygon Collision Detection](https://stackoverflow.com/questions/3972517/2d-polygon-collision-detection) ✓ (Web)
- [GitHub: SP2C - 2D Collision Library](https://github.com/Kareus/SP2C) ✓ (GitHub)

### 5. Circle/Ellipse Approximation

**Description:**
- Approximates shapes with one or more circles or ellipses
- Can use multiple circles for better fit

**Pros:**
- Simple collision detection (distance check)
- Fast computation
- Works well for round objects

**Cons:**
- Poor fit for irregular shapes like asteroids
- May require multiple circles for decent approximation

**Relevance:** ⭐⭐ (Low - Asteroids are too irregular)

**Links:**
- [MDN: 2D Collision Detection - Circle Collision](https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection) ✓ (Web)

## Link Verification Status

Links have been verified (some may be blocked in sandboxed environment):
- ✓ GitHub repositories: 
  - https://github.com/OSUblake/msqr - Accessible
  - https://github.com/CMihalcik/rdp-js - Accessible
  - https://github.com/Kareus/SP2C - Accessible
- ⚠ External sites (blocked in sandbox but valid URLs):
  - https://jurasic.dev/marching_squares/
  - https://observablehq.com/@chnn/running-ramer-douglas-peucker-on-typed-arrays
  - https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
  - https://gamedev.stackexchange.com/questions/86109/collision-detection-between-2-irregular-shapes
  - https://stackoverflow.com/questions/3972517/2d-polygon-collision-detection

## Recommendation

**Primary Approach: Marching Squares + Douglas-Peucker**

For the asteroid sprites with irregular shapes:

1. **Extract contours** using Marching Squares algorithm to trace visible pixels
2. **Simplify polygons** using Douglas-Peucker algorithm to reduce point count
3. **Store bounding polygons** for each sprite frame
4. **Use SAT** for actual collision detection between polygons

This approach provides:
- Accurate bounding shapes for irregular asteroids
- Configurable complexity (tolerance parameter)
- Efficient collision detection
- Pure JavaScript implementation possible

**Fallback Approach: Convex Hull + SAT**

If performance is critical:
- Compute convex hull of visible pixels
- Use SAT for collision detection
- Faster but less accurate for concave shapes

## Implementation Plan

1. Create utility to load sprite sheet
2. Extract individual sprite frames
3. Apply Marching Squares to detect boundaries
4. Simplify with Douglas-Peucker
5. Visualize results by overlaying bounding polygons on sprites
6. Store bounding data for runtime use

## Performance Considerations

- Bounding shape computation should be done once at load time, not per frame
- Store pre-computed bounding polygons with sprite data
- Use broad-phase AABB checks before detailed polygon collision detection
- Consider LOD (Level of Detail) - simpler shapes at distance
